---
layout: ../../layouts/Post.astro
title: 'Code Review 也是一门技术活'
pubDate: 2025-05-19
updatedDate: 2025-06-09
description: '即将成为三年工作经验的码仔，记录下一些 Code Review 环节强烈建议做的事情，在开发阶段严格自查，是最经济的投入，如果到了实际产品上线后才暴漏，危已危已。'
author: 'kok-s0s'
image:
  url: '/images/code_review/review.jpg'
  alt: 'Qt'
tags: ['Code Review']
---

## 多线程共享数据访问 Checklist

### 一、是否存在多线程访问？

| 检查项                             | 说明                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| 是否有多个线程访问同一变量/数据？  | 比如定时器、回调函数、后台线程等                             |
| 是否有跨线程信号/槽连接？          | 非默认连接类型，如 `Qt` 中的 `QueuedConnection` 会跨线程触发 |
| 是否涉及全局对象、单例或共享引用？ | 容易被多个线程同时读写                                       |

### 二、是否有并发读写？

| 检查项                             | 说明                                           |
| ---------------------------------- | ---------------------------------------------- |
| 是否存在一个线程写、另一个线程读？ | 即使写入频率不高，也有风险                     |
| 是否对容器进行添加/删除操作？      | 如 append、remove、insert 都属于修改操作       |
| 是否使用了非线程安全的数据结构？   | Qt 容器（QList, QVector 等）默认不是线程安全的 |

### 三、是否做了同步保护？

| 检查项                              | 说明                                 |
| ----------------------------------- | ------------------------------------ |
| 是否使用锁机制保护共享数据？        | 如 QMutex、QReadWriteLock 等         |
| 锁是否作用在整个访问/修改操作区域？ | 尤其是多行操作时，必须全包住         |
| 是否使用了自动锁（RAII）？          | 避免忘记 unlock（例如 QMutexLocker） |
| 是否避免在锁内做耗时操作？          | 避免死锁、卡界面                     |

### 四、结构是否合理可扩展？

| 检查项                                       | 说明                                                      |
| -------------------------------------------- | --------------------------------------------------------- |
| 是否将锁作为成员变量，保护整个资源生命周期？ | 保证资源和锁是强绑定的                                    |
| 是否需要封装线程安全容器？                   | 如 ThreadSafeQueue、ThreadSafeMap 等                      |
| 是否设计了线程通信机制？                     | 如条件变量、线程安全队列、事件派发机制等                  |
| 是否需要将工作逻辑放入单独线程？             | 利用 `QThread`、任务队列、信号/槽通信更清晰地解耦线程逻辑 |

### 五、是否有测试或监控机制？

| 检查项                                | 说明                                   |
| ------------------------------------- | -------------------------------------- |
| 是否使用断言或日志检测异常访问？      | 加入一致性检查，发现边界情况           |
| 是否在 debug 模式下主动测试线程交叉？ | 强化测试不同线程交互顺序，发现潜在问题 |
| 是否出现过偶现崩溃、未定义行为？      | 若是，很大可能是线程安全问题导致的     |

### 其它实际建议

- 在代码注释或 PR Review 中标注“此处涉及多线程访问，已加锁”。
- 出现崩溃/偶现 bug 时，特别是访问数据内存相关的，可优先回顾是否涉及多线程共享数据访问。

## Code Format && Git commit

> 我现在有一个浅薄的观点，就是一个程序员吧，如果会 code format，且 Git 的 commit 信息写的条理清晰，就感觉已经超过 75% 左右的程序员了。

### Code Format 体现基础素养

统一的代码格式意味着：

- 代码可读性高；

- 减少了代码 review 的沟通成本；

- 有助于长期维护；

实际开发中，有太多人不关心这一点，或者仅仅依赖 IDE 的默认格式，导致团队代码风格混乱。

会熟练使用 clang-format、.editorconfig 或 prettier 的人，真的不多。

### Commit 信息清晰是协作力的体现

清晰的 commit message（如遵循 Conventional Commits）能让团队成员快速理解每一次改动的目的。

也体现了开发者的思考方式：是否有结构、有总结力、有文档意识。

在大型团队或 CI/CD 中，良好的 commit 甚至直接影响上线节奏与回滚效率。

> 上述这两个习惯是“可见的内功”，很多高级技能是“看不出来”的，比如底层优化、架构设计；
> 而格式与 commit 这种，是你一打开 repo 就能看见的。

### 举个栗子

两个 PR：

- **A：**

  ```cpp
  void foo(int x){if(x>0){bar(x);}}
  ```

  Commit: `fix bug`

- **B：**

  ```cpp
  void foo(int x)
  {
      if (x > 0)
      {
          bar(x);
      }
  }
  ```

  Commit: `fix: call bar only when x > 0 to avoid crash (#134)`

会更信任哪一个？毫无疑问是 B。

## 面向对象代码 Code Review Checklist（C++ / Qt）

### 类设计与职责（Class Design）

- 类是否只有一个清晰的职责？（SRP）
- 类是否过于臃肿？是否应该拆分？
- 类命名是否能直观表达其作用？

### 封装与访问控制（Encapsulation）

- 是否存在不必要的 `public` 成员？
- 是否恰当地使用了 `private` / `protected`？
- 数据成员是否隐藏在类内部，并通过 getter/setter 暴露？

### 依赖管理与解耦（Dependency & Coupling）

- 是否硬编码依赖其他类？是否可以通过接口或构造函数注入？
- 是否存在隐藏的依赖（如全局单例、静态变量等）？
- 是否便于 mock / 单元测试？

### 继承 vs 组合（Inheritance vs Composition）

- 当前的继承结构是否合理？是否遵循了 Liskov 替换原则（LSP）？
- 是否可以使用组合替代继承？
- Qt 中 QObject 的继承是否必要？是否破坏了 QObject 树？

### 构造函数与资源管理（RAII）

- 是否使用了智能指针或 Qt 的父子机制来管理资源？
- 构造函数是否承担了过多初始化工作？
- 是否正确实现了析构函数释放资源？

### 可读性与命名

- 命名是否清晰、表达明确？
- 是否存在 `Helper`, `Utils`, `Manager` 等过于宽泛的类名？
- 函数是否过长？是否可以拆分为小函数？

### 结构与模块边界

- 该类/模块是否有明确的输入输出边界？
- 是否与 UI / 业务 / IO 层紧耦合？
- 是否便于在单元测试或集成测试中使用？

### Qt 特有建议

- signal/slot 是否职责清晰？是否造成逻辑散乱？
- 是否过度使用 lambda slot，导致调试困难？
- 是否正确使用 Qt 的 parent 指针管理对象生命周期？

---

如果以上大部分都做到了，那么所编写的 OOP 代码就已经有很高的结构性和可维护性了。
