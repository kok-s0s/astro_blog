---
title: 'struct 内存对齐问题，sizeof 与 strlen 区别'
---

在 C/C++ 编程中，`struct` 的内存对齐以及 `sizeof` 和 `strlen` 之间的区别是常见的概念。我们逐一说明。

# 1. `struct` 的内存对齐问题
C/C++ 中，`struct` 的成员会按照某种对齐方式存储，以提高内存访问的效率。内存对齐指的是编译器在分配内存时，会按照数据类型的对齐要求进行填充（即可能在成员之间加入一些未使用的空间），确保每个成员的地址都是适合其类型的地址。

例如，对于 32 位系统，`int` 类型可能要求以 4 字节对齐，因此编译器会将 `int` 变量存储在能被 4 整除的地址上。如果 `struct` 中有多个不同类型的成员，那么它们之间可能会存在“填充字节”。

## 示例：
```cpp
#include <iostream>

struct Example {
    char a;
    int b;
    short c;
};

int main() {
    std::cout << "Size of Example struct: " << sizeof(Example) << std::endl;
    return 0;
}
```

在上述示例中，`char a` 只占用 1 字节，而 `int b` 可能需要对齐到 4 字节，因此会有 3 字节的填充。`short c` 可能需要 2 字节的对齐。因此，这个 `struct` 的大小并不是简单的所有成员字节数之和，而是经过对齐后的大小。

# 2. `sizeof` 与 `strlen` 的区别

## `sizeof`
`sizeof` 是一个编译时操作符，用于获取变量或类型的字节大小。对于数组、结构体等，它返回的是整个对象占用的字节数，包括任何可能的填充字节。

例如：
```cpp
char arr[] = "Hello";
std::cout << sizeof(arr) << std::endl; // 输出 6，因为包含了末尾的 '\0'
```

`sizeof` 计算的是整个对象的大小，因此对于 `struct`，它会考虑内存对齐产生的填充。

## `strlen`
`strlen` 是一个函数，用于计算字符串的长度（不包括末尾的 `'\0'`）。它仅适用于 C 风格的字符串，并且计算的是字符数组中字符的实际数量，直到遇到字符串的结束符 `'\0'` 为止。

例如：
```cpp
char arr[] = "Hello";
std::cout << strlen(arr) << std::endl; // 输出 5，因为不包括末尾的 '\0'
```

## 主要区别
- `sizeof` 用于计算任何类型的内存大小，包括数组、结构体、指针等，结果是整个对象的字节数。
- `strlen` 仅用于计算 C 风格字符串的长度（字符数），不包括终止符 `'\0'`。

## 总结
- `sizeof` 计算内存大小，适用于任意类型。
- `strlen` 计算 C 风格字符串的字符长度，不包括 `'\0'`。
- `struct` 的内存对齐可能导致 `sizeof` 结果大于所有成员字节数的总和。
